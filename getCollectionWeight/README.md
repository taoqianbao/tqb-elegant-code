## 案例说明

假设这样一个场景，需要实现一个函数，用于计算 array、map 或 普通 JavaScript 对象的权重。总权重可通过计算各成员权重获得：

- null 或者 未定义变量计 1 点。
- 基本类型计 2 点。
- 对象或函数计 4 点。

例如，数组 [null, ‘Hello World’, {}] 的权重这样计算：1（null） + 2（string 是基本类型） + 4（对象） = 7。

Step 0: 最初的大函数

我们从最糟的实例开始。所有的逻辑都被编码在函数 getCollectionWeight() 中:
```JS
step0.js
```

问题显而易见，getCollectionWeight() 函数超级长，而且看起来像一个装满“意外”的黑盒子。可能你也发现了，第一眼根本就搞不明白它要干什么。再试想一下，应用里有大把这样的函数。

在工作中遇到这样的代码，就是在浪费你的时间和精力。反之，高质量的代码不会令人不适。高质量代码中，那些精巧、自文档极好的函数非常易于阅读和理解。




Step 1：根据类型计算权重，抛弃那些“迷之数字”。

现在，我们的目标是：把这个巨型函数，拆分为较小的、独立的、可重用的一组函数。第一步，将根据类型计算权重的代码提取出来。这个新的函数命名为 getWeight()。

我们再看看这几个“迷之数字”: 1, 2, 4。在不知道整个故事背景的前提下，仅靠这几个数字提供不了任何有用的信息。幸好 ES2015 允许定义静态只读引用，那你就能简单的创造几个常量，用有意义的名称，替换掉那几个“迷之数字”。（我特别喜欢“迷之数字”这个说法：D）

我们来新建一个较小的函数 getWeightByType()，并用它来改进 getCollectionWeight()：

```JS
step1.js
```

看起来好多了，对吧？ getWeightByType() 函数是一个独立的组件，仅仅用于决定各类型的权重值。而且它是可复用的，你可以在其他任何函数中使用它。

getCollectionWeight() 稍微瘦了点身。

WEIGHT_NULL_UNDEFINED, WEIGHT_PRIMITIVE 还有 WEIGHT_OBJECT_FUNCTION 都是具备自文档能力的常量，通过它们的名字就可以看出各类型的权重。你就不需要猜测 1、2、4 这些数字的意义。



Step 2: 继续切分，使之具备扩展性

然而，这个升级版依然有不足的地方。假如你打算对一个 Set，甚至其他用户自定义集合来实现权值计算。getCollectionWeight() 会快速膨胀，因为它包含了一组获得权值的具体逻辑。

让我们将获得 maps 权重的代码提取到 getMapValues()，将获得基本 JavaScript 对象权值的代码则放到 getPlainObjectValues() 中。看看改进后的版本吧。

```JS
step2.js
```

现在再来看 getCollectionWeight() 函数，你会发现已经比较容易明白它的机理，看起来就像一段有趣的故事。

每一个函数的简单明了。你不需要花费时间去挖掘代码，理解代码的工作。这就是清新版代码该有的样子。



Step 3: 优化永无止境

原则上，你的函数不应当超过 20 行——越小越好。

现在，我觉得你可能会问我这样的问题：“我可不想将每一行代码都写为函数。有没有什么准则，告诉我何时应当停止拆分？”。这就是接下来的议题了。




### 感谢

[http://blog.jobbole.com/106720/](http://blog.jobbole.com/106720/)